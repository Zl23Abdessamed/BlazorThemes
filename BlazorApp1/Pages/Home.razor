@page "/"
@using Microsoft.AspNetCore.Components.Web
@using BlazorThemes.Components
@using BlazorThemes.Services
@using System.Text.Json

@*
    Inject the service directly. While the CascadingParameter works,
    direct injection is often clearer for the component's primary logic.
*@
@inject BlazorThemesService ThemesService

<PageTitle>Theme Switcher Test</PageTitle>

@*
    The provider now only needs the static initial options. All dynamic changes
    (like enabling scheduling) will be handled by calling service methods directly.
*@
<BlazorThemesProvider Options="@themeOptions"
                      OnThemeChanged="OnThemeChangedHandler"
                      OnSystemThemeChanged="OnSystemThemeChangedHandler"
                      OnProviderInitialized="OnInitializedHandler"
                      OnTransitionStateChanged="OnTransitionStateChangedHandler">

    <div class="theme-test-container">
        <header class="test-header">
            <h1>🎨 Theme Switcher Test Page</h1>
            <div class="current-theme-info">
                @if (providerInitialized)
                {
                    <span class="theme-badge">Current: @ThemesService.State.ResolvedTheme</span>
                    <span class="theme-badge">System: @ThemesService.State.SystemTheme</span>
                    <span class="theme-badge">Selected: @ThemesService.State.Theme</span>
                    @if (ThemesService.State.IsTransitioning)
                    {
                        <span class="theme-badge transitioning">Transitioning...</span>
                    }
                }
                else
                {
                    <span class="theme-badge">Initializing...</span>
                }
            </div>
        </header>

        <div class="test-sections">
            <!-- Basic Theme Controls -->
            <section class="test-section">
                <h2>🔄 Basic Theme Controls</h2>
                <div class="button-group">
                    <button class="btn btn-light" @onclick='() => SetTheme("light")'>☀️ Light</button>
                    <button class="btn btn-dark" @onclick='() => SetTheme("dark")'>🌙 Dark</button>
                    <button class="btn btn-auto" @onclick='() => SetTheme("auto")'>🔄 Auto</button>
                    <button class="btn btn-toggle" @onclick="ToggleTheme">🔀 Toggle</button>
                </div>
            </section>

            <!-- Transition Effects -->
            <section class="test-section">
                <h2>✨ Transition Effects</h2>
                <div class="button-group">
                    <button class="btn btn-effect" @onclick="() => SetThemeWithTransition(ThemeTransitionType.Fade)">🌅 Fade</button>
                    <button class="btn btn-effect" @onclick="() => SetThemeWithTransition(ThemeTransitionType.Slide)">📱 Slide</button>
                    <button class="btn btn-effect" @onclick="() => SetThemeWithTransition(ThemeTransitionType.Blur)">🌫️ Blur</button>
                    <button class="btn btn-effect" @onclick="HandleRippleClick">💧 Ripple (Click me!)</button>
                </div>
            </section>

            <!-- Custom Themes -->
            <section class="test-section">
                <h2>🎨 Custom Themes</h2>
                <div class="custom-theme-controls">
                    <div class="input-group">
                        <input @bind="newThemeName" placeholder="Theme name" class="theme-input" />
                        <button class="btn btn-add" @onclick="AddCustomTheme">➕ Add Theme</button>
                    </div>
                    @if (ThemesService.State.CustomThemes.Any())
                    {
                        <div class="custom-themes-list">
                            @foreach (var theme in ThemesService.State.CustomThemes)
                            {
                                <div class="custom-theme-item">
                                    <button class="btn btn-custom" @onclick="() => SetTheme(theme)">🎯 @theme</button>
                                    <button class="btn btn-remove" @onclick="() => RemoveCustomTheme(theme)">❌</button>
                                </div>
                            }
                        </div>
                    }
                </div>
            </section>

            <!-- Theme Scheduling -->
            <section class="test-section">
                <h2>⏰ Theme Scheduling</h2>
                <div class="scheduling-controls">
                    <label class="checkbox-label">
                        @* BIND DIRECTLY TO A PROPERTY THAT CALLS THE SERVICE *@
                        <input type="checkbox" @bind="IsSchedulingEnabled" />
                        Enable automatic scheduling
                    </label>

                    @if (IsSchedulingEnabled)
                    {
                        <div class="time-controls">
                            <div class="time-input-group">
                                <label>Light theme starts:</label>
                                <input type="time" @bind="LightStartTime" class="time-input" />
                            </div>
                            <div class="time-input-group">
                                <label>Dark theme starts:</label>
                                <input type="time" @bind="DarkStartTime" class="time-input" />
                            </div>
                        </div>
                    }
                </div>
            </section>

            <!-- Advanced Controls & Info -->
            <section class="test-section">
                <h2>🔧 Advanced Controls & Info</h2>
                <div class="button-group">
                    <button class="btn btn-force" @onclick='() => ForceTheme("dark")'>🔒 Force Dark</button>
                    <button class="btn btn-force" @onclick="ClearForcedTheme">🔓 Clear Forced</button>
                    <button class="btn btn-cycle" @onclick="CycleTheme">🔄 Cycle Themes</button>
                    <button class="btn btn-refresh" @onclick="RefreshState">🔄 Refresh State</button>
                </div>

                @if (providerInitialized)
                {
                    <div class="info-grid">
                        <div class="info-item"><strong>Available:</strong> <span>@string.Join(", ", ThemesService.State.Themes)</span></div>
                        <div class="info-item"><strong>Forced:</strong> <span>@(ThemesService.State.ForcedTheme ?? "None")</span></div>
                        <div class="info-item"><strong>Transition:</strong> <span>@ThemesService.State.TransitionType</span></div>
                    </div>
                }
            </section>
        </div>

        <section class="event-log">
            <h3>📝 Event Log</h3>
            <div class="log-content" style="height: 200px; overflow-y: scroll; border: 1px solid #ccc; padding: 10px; background: #f9f9f9;">
                @foreach (var log in eventLog.TakeLast(50).Reverse())
                {
                    <div class="log-entry" style="color: @log.Color">
                        <span class="log-time">@log.Time.ToString("HH:mm:ss.fff")</span>
                        <span class="log-message"> - @log.Message</span>
                    </div>
                }
            </div>
        </section>
    </div>
</BlazorThemesProvider>

@code {
    private bool providerInitialized = false;
    private string newThemeName = "";

    // Initial, static options for the provider.
    private ThemeOptions themeOptions = new ThemeOptions
    {
        Themes = new[] { "light", "dark", "auto" },
        CustomThemes = new[] { "sepia" }, // Let's pre-define one
        StorageKey = "blazor-theme-test-fixed",
        EnableSystem = true,
        EnableColorScheme = true,
        DisableTransitionOnChange = false,
        TransitionDuration = 300,
        TransitionType = "fade"
    };

    // --- Logging ---
    private List<LogEntry> eventLog = new();
    private class LogEntry
    {
        public DateTime Time { get; set; } = DateTime.Now;
        public string Message { get; set; } = "";
        public string Color { get; set; } = "black";
    }

    private void LogEvent(string message, string color = "black")
    {
        Console.WriteLine($"LOG: {message}");
        eventLog.Add(new LogEntry { Message = message, Color = color });
        StateHasChanged();
    }

    // --- State Properties (The Correct Way) ---
    // These properties act as a bridge between the UI and the Service.
    // The 'get' reads from the service's state.
    // The 'set' calls a method on the service to change the state.

    private bool IsSchedulingEnabled
    {
        get => ThemesService?.State.SchedulingEnabled ?? false;
        set
        {
            if (ThemesService != null && ThemesService.State.SchedulingEnabled != value)
            {
                LogEvent($"UI wants to set scheduling to: {value}", "blue");
                _ = ThemesService.EnableSchedulingAsync(value);
            }
        }
    }

    private DateTime LightStartTime
    {
        get => DateTime.TryParse(ThemesService?.State.ScheduleConfig.LightStart, out var time) ? DateTime.Today.Add(time.TimeOfDay) : DateTime.Today;
        set
        {
            if (ThemesService != null)
            {
                var timeString = value.ToString("HH:mm");
                if (ThemesService.State.ScheduleConfig.LightStart != timeString)
                {
                    LogEvent($"UI wants to set light start time to: {timeString}", "blue");
                    _ = ThemesService.SetScheduleAsync(timeString, ThemesService.State.ScheduleConfig.DarkStart);
                }
            }
        }
    }

    private DateTime DarkStartTime
    {
        get => DateTime.TryParse(ThemesService?.State.ScheduleConfig.DarkStart, out var time) ? DateTime.Today.Add(time.TimeOfDay) : DateTime.Today;
        set
        {
            if (ThemesService != null)
            {
                var timeString = value.ToString("HH:mm");
                if (ThemesService.State.ScheduleConfig.DarkStart != timeString)
                {
                    LogEvent($"UI wants to set dark start time to: {timeString}", "blue");
                    _ = ThemesService.SetScheduleAsync(ThemesService.State.ScheduleConfig.LightStart, timeString);
                }
            }
        }
    }

    // --- Button Click Handlers ---

    private async Task SetTheme(string theme)
    {
        LogEvent($"Attempting to set theme to '{theme}'...");
        if (ThemesService == null) { LogEvent("Service is NULL!", "red"); return; }
        await ThemesService.SetThemeAsync(theme);
    }

    private async Task ToggleTheme()
    {
        LogEvent("Attempting to toggle theme...");
        if (ThemesService == null) { LogEvent("Service is NULL!", "red"); return; }
        await ThemesService.ToggleThemeAsync();
    }

    private async Task SetThemeWithTransition(ThemeTransitionType transitionType)
    {
        LogEvent($"Attempting to toggle theme with transition: {transitionType}...");
        if (ThemesService == null) { LogEvent("Service is NULL!", "red"); return; }
        await ThemesService.ToggleThemeWithTransitionAsync(transitionType);
    }

    private async Task HandleRippleClick(MouseEventArgs e)
    {
        LogEvent($"Attempting ripple click at ({e.ClientX}, {e.ClientY})...");
        if (ThemesService == null) { LogEvent("Service is NULL!", "red"); return; }
        var newTheme = ThemesService.ResolvedTheme == "light" ? "dark" : "light";
        await ThemesService.SetThemeWithRippleAsync(newTheme, e.ClientX, e.ClientY);
    }

    private async Task AddCustomTheme()
    {
        LogEvent($"Attempting to add custom theme: '{newThemeName}'...");
        if (ThemesService == null) { LogEvent("Service is NULL!", "red"); return; }
        if (string.IsNullOrWhiteSpace(newThemeName)) { LogEvent("Theme name is empty.", "orange"); return; }

        await ThemesService.AddCustomThemeAsync(newThemeName, new Dictionary<string, string> { ["background-color"] = "#f0e6d2" });
        newThemeName = "";
    }

    private async Task RemoveCustomTheme(string themeName)
    {
        LogEvent($"Attempting to remove custom theme: '{themeName}'...");
        if (ThemesService == null) { LogEvent("Service is NULL!", "red"); return; }
        await ThemesService.RemoveCustomThemeAsync(themeName);
    }

    private async Task ForceTheme(string theme)
    {
        LogEvent($"Attempting to force theme: '{theme}'...");
        if (ThemesService == null) { LogEvent("Service is NULL!", "red"); return; }
        await ThemesService.ForceThemeAsync(theme);
    }

    private async Task ClearForcedTheme()
    {
        LogEvent("Attempting to clear forced theme...");
        if (ThemesService == null) { LogEvent("Service is NULL!", "red"); return; }
        await ThemesService.ClearForcedThemeAsync();
    }

    private async Task CycleTheme()
    {
        LogEvent("Attempting to cycle theme...");
        if (ThemesService == null) { LogEvent("Service is NULL!", "red"); return; }
        await ThemesService.CycleThemeAsync();
    }

    private async Task RefreshState()
    {
        LogEvent("Attempting to refresh state...");
        if (ThemesService == null) { LogEvent("Service is NULL!", "red"); return; }
        await ThemesService.RefreshStateAsync();
    }

    // --- Event Callbacks from the Provider ---

    private void OnInitializedHandler()
    {
        providerInitialized = true;
        LogEvent("✅ Event: Provider Initialized!", "green");
        StateHasChanged();
    }

    private void OnThemeChangedHandler(ThemeState state)
    {
        var stateJson = JsonSerializer.Serialize(state);
        LogEvent($"🎨 Event: Theme Changed! New state: {stateJson}", "purple");
        StateHasChanged(); // Essential to re-render the UI with new state
    }

    private void OnSystemThemeChangedHandler(string systemTheme)
    {
        LogEvent($"💻 Event: System Theme Changed to '{systemTheme}'!", "teal");
    }

    private void OnTransitionStateChangedHandler(bool isTransitioning)
    {
        LogEvent($"✨ Event: IsTransitioning state is now {isTransitioning}", "darkgoldenrod");
    }
}